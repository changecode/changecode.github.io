<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>ReentrantReadWriteLock | 阿修罗</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="阿修罗">
    <meta name="author" content="changecode">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="阿修罗" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">阿修罗</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2017-10-30T02:07:21.000Z" itemprop="datePublished">
          2017-10-30
      </time>
    
</span>
                <h1>ReentrantReadWriteLock</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReadWriteLock:维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有writer，读取锁可以由多个reader线程同时保持。写入锁是独占的。对于ReadWriteLock而言，一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</p>
<pre><code>public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
</code></pre><p>ReentrantReadWriteLock作为ReadWriteLock的实现类，特性如下:</p>
<p>1、公平性</p>
<pre><code>1. 非公平锁(默认)和独占锁的非公平性一样，由于读线程之间没有锁竞争，所以读操作没有公平性和非公平性之分，写操作时，由于写操作可能理解获取到锁，所以会推迟一个或多个读操作或者写操作。

2. 公平说利用AQS的CLH队列，释放当前保存的锁时，优先为等待时间最长的那个写线程分配写入锁，当前前提是写线程的等待时间要比所有读线程的等待时间要长。同样一个线程持有写入锁或者有一个写线程已经在等待了，那么试图获取公平锁的(非重入)所有线程都将被阻塞，直到最先的写线程释放锁。如果读线程的等待时间比写线程的等待时间还要长，那么一旦上一个写线程释放锁，这一个线程将获取锁
</code></pre><p>2、重入性</p>
<pre><code>1. 读写锁运行读线程和谐线程按照请求锁的顺序重新获取读取锁或者写入锁

2. 写线程获取写入锁后可以再次获取读取锁，但是读线程获取读取锁却不能获取写入锁

3. 读写锁最多支持65535个递归写入锁和65535个递归读取锁    
</code></pre><p>3、锁降级</p>
<pre><code>1. 写线程获取写入锁后可以获取读取锁，然后师傅写入锁，写入锁就变成了读取锁，从而实现锁的降级
</code></pre><p>4、锁升级</p>
<pre><code>1. 读取锁是不能直接升级为写入锁的。因为获取一个写入锁需要释放所有的读取锁，如果有二个读取锁试图获取写入锁而都不释放读取锁时会发生死锁
</code></pre><p>5、锁获取中断</p>
<pre><code>1. 读取锁和写入锁都支持获取锁期间被中断
</code></pre><p>6、条件变量</p>
<pre><code>1. 写入锁提供了条件变量的支持，这个和独占锁一致，但是读取锁却不运行获取条件变量
</code></pre><p>7、重入数</p>
<pre><code>1. 读取锁和写入锁的数量最大分部只能是65535                      
</code></pre><h2 id="WriteLock-lock"><a href="#WriteLock-lock" class="headerlink" title="WriteLock-lock"></a>WriteLock-lock</h2><pre><code>public void lock() {
    sync.acquire(1);
}
====
public final void acquire(int arg) {
if (!tryAcquire(arg) &amp;&amp;
    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    selfInterrupt();
}
====
protected final boolean tryAcquire(int acquires) {
    //当前线程
    Thread current = Thread.currentThread();
    //当前锁个数
    int c = getState();
    //写锁个数
    int w = exclusiveCount(c);

    //当前锁个数 != 0（是否已经有线程持有锁），线程重入
    if (c != 0) {
        //w == 0,表示写线程数为0
        //或者独占锁不是当前线程，返回false
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;

        //超出最大范围（65535）
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        //设置锁的线程数量
        setState(c + acquires);
        return true;
    }

    //是否阻塞
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;

    //设置锁为当前线程所有
    setExclusiveOwnerThread(current);
    return true;
}
</code></pre><p>独占锁ReentrantLock中有个state，共享锁也有一个state，其中独占锁中的state为0或者1，如果有重入，则表示重入的次数，共享锁中表示的持有锁的数量。而ReadWriteLock中则不同，由于其存在二个锁，之间还有联系，所以需要二个state分别表示，于是将state一分为二，高16位表示共享锁的数量，低16位表示独占锁的数量2^16-1=65535</p>
<h2 id="WriteLock-unlock"><a href="#WriteLock-unlock" class="headerlink" title="WriteLock-unlock"></a>WriteLock-unlock</h2><pre><code>public void unlock() {
    sync.release(1);
}
====
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
====
protected final boolean tryRelease(int releases) {
    //若锁的持有者不是当前线程，抛出异常
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    //写锁的新线程数
    int nextc = getState() - releases;
    //若写锁的新线程数为0，则将锁的持有者设置为null
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
    //设置写锁的新线程数
    setState(nextc);
    return free;
}
</code></pre><p>写锁的释放过程还是相对而言比较简单的：首先查看当前线程是否为写锁的持有者，如果不是抛出异常。然后检查释放后写锁的线程数是否为0，如果为0则表示写锁空闲了，释放锁资源将锁的持有线程设置为null，否则释放仅仅只是一次重入锁而已，并不能将写锁的线程清空</p>
<h2 id="ReadLock-lock"><a href="#ReadLock-lock" class="headerlink" title="ReadLock-lock"></a>ReadLock-lock</h2><pre><code>public void lock() {
    sync.acquireShared(1);
}
====
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
====
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    //锁的持有线程数
    int c = getState();
    /*
     * 如果写锁线程数 != 0 ，且独占锁不是当前线程则返回失败，因为存在锁降级
     */
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    //读锁线程数
    int r = sharedCount(c);
    /*
     * readerShouldBlock():读锁是否需要等待（公平锁原则）
     * r &lt; MAX_COUNT：持有线程小于最大数（65535）
     * compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态
     */
    if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        /*
         * holdCount部分后面讲解
         */
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;        //
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != current.getId())
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
</code></pre><p>1、写锁的线程数C！=0且写锁的线程持有者不是当前线程，返回-1。因为存在锁降级，写线程获取写入锁后可以获取读取锁。</p>
<p>2、依据公平性原则，判断读锁是否需要阻塞，读锁持有线程数小于最大值（65535），且设置锁状态成功，执行以下代码（对于HoldCounter下面再阐述），并返回1。如果不满足改条件，执行fullTryAcquireShared()：（HoldCounter部分后面讲解）      </p>
<pre><code>final int fullTryAcquireShared(Thread current) {
     HoldCounter rh = null;
     for (;;) {
         //锁的线程持有数
         int c = getState();
         //如果写锁的线程持有数 != 0 且锁的持有者不是当前线程，返回-1
         if (exclusiveCount(c) != 0) {
             if (getExclusiveOwnerThread() != current)
                 return -1;
         } 
         //若读锁需要阻塞
         else if (readerShouldBlock()) {
             //若队列的头部是当前线程
             if (firstReader == current) {
             } 
             else {   //下面讲解
                 if (rh == null) {
                     rh = cachedHoldCounter;
                     if (rh == null || rh.tid != current.getId()) {
                         rh = readHolds.get();
                         if (rh.count == 0)
                             readHolds.remove();
                     }
                 }
                 if (rh.count == 0)
                     return -1;
             }
         }
         //读锁的线程数到达最大值：65536，抛出异常
         if (sharedCount(c) == MAX_COUNT)
             throw new Error(&quot;Maximum lock count exceeded&quot;);
         //设置锁的状态成功
         if (compareAndSetState(c, c + SHARED_UNIT)) {
             if (sharedCount(c) == 0) {
                 firstReader = current;
                 firstReaderHoldCount = 1;
             }
             else if (firstReader == current) {
                 firstReaderHoldCount++;
             }
             else {
                 if (rh == null)
                 rh = cachedHoldCounter;
                 if (rh == null || rh.tid != current.getId())
                     rh = readHolds.get();
                 else if (rh.count == 0)
                     readHolds.set(rh);
                 rh.count++;
                 cachedHoldCounter = rh;
             }
             return 1;
         }
     }
 }  
</code></pre><h2 id="ReadLock-unlock"><a href="#ReadLock-unlock" class="headerlink" title="ReadLock-unlock"></a>ReadLock-unlock</h2><pre><code>public  void unlock() {
    sync.releaseShared(1);
}
====
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
====
protected final boolean tryReleaseShared(int unused) {
    //当前线程
    Thread current = Thread.currentThread();
    /*
     * HoldCounter部分后面阐述
     */
    if (firstReader == current) {
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    } else {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != current.getId())
            rh = readHolds.get();
        int count = rh.count;
        if (count &lt;= 1) {
            readHolds.remove();
            if (count &lt;= 0)
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
    //不断循环，不断尝试CAS操作
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
</code></pre><h2 id="HoldCounter"><a href="#HoldCounter" class="headerlink" title="HoldCounter"></a>HoldCounter</h2><p>对于共享锁其实我们可以稍微的认为它不是一个锁的概念，它更加像一个计数器的概念。一次共享锁操作就相当于一次计数器的操作，获取共享锁计数器+1，释放共享锁计数器-1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。所以HoldCounter的作用就是当前线程持有共享锁的数量，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常</p>
<pre><code>if (r == 0) {        //r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中
    firstReader = current;
    firstReaderHoldCount = 1;
} else if (firstReader == current) {    //第一个读锁线程重入
    firstReaderHoldCount++;    
} else {    //非firstReader计数
    HoldCounter rh = cachedHoldCounter;        //readHoldCounter缓存
    //rh == null 或者 rh.tid != current.getId()，需要获取rh
    if (rh == null || rh.tid != current.getId())    
        cachedHoldCounter = rh = readHolds.get();
    else if (rh.count == 0)
        readHolds.set(rh);        //加入到readHolds中
    rh.count++;        //计数+1
}     
</code></pre><p>HoldCounter应该就是绑定线程上的一个计数器，而ThradLocalHoldCounter则是线程绑定的ThreadLocal。从上面我们可以看到ThreadLocal将HoldCounter绑定到当前线程上，同时HoldCounter也持有线程Id，这样在释放锁的时候才能知道ReadWriteLock里面缓存的上一个读取线程（cachedHoldCounter）是否是当前线程。这样做的好处是可以减少ThreadLocal.get()的次数，因为这也是一个耗时操作。需要说明的是这样HoldCounter绑定线程id而不绑定线程对象的原因是避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们（尽管GC能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助GC快速回收对象而已               </p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/2017/10/30/ReentrantLock-unlock/" style="float: left;">
        ← ReentrantLock-unlock
    </a>
    
    
    <a class="pull-right" href="/2017/10/30/Semaphore/">
        Semaphore →
    </a>
    
</nav>

        <div class="duoshuo">


</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By changecode. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      (function(){
        console.log('font');
        var getCss = function(path) {
          var head = document.getElementsByTagName('head')[0];
          link = document.createElement('link');
          link.href = path;
          link.rel = 'stylesheet';
          link.type = 'text/css';
          head.appendChild(link);
        };
        getCss('https://fonts.googleapis.com/css?family=Montserrat:400,700');
        getCss('https://fonts.googleapis.com/css?family=Open+Sans:400,600');
      })();
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
